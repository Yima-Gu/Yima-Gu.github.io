---
syntax_converted: true
---


> [!TIP] **本节导读：网络安全的核心逻辑与知识图谱**
> 
> 本章不仅仅是介绍加密算法，而是构建一套解决网络中“信任”问题的工具箱。学习时请遵循以下**层层递进**的逻辑链条：
> 
> 1.  **明确目标 (四大属性)**：网络安全不只是加密（机密性），还必须保证数据的**完整性**（没被改过）、**身份认证**（你是谁）以及**可用性**。
> 2.  **掌握工具 (密码学基石)**：
>     * **对称加密 (DES/AES)**：效率高，适合加密大数据，但面临密钥分发难题。
>     * **公钥加密 (RSA)**：解决了密钥分发问题，支持数字签名，但计算慢。**RSA 的数学推导**（模运算与欧拉定理）是理论难点。
> 3.  **构建机制 (防御策略)**：
>     * **哈希与 MAC**：解决“完整性”问题。
>     * **Nonce (随机数)**：解决身份认证中的 **“重放攻击”**。
>     * **数字签名与 CA**：解决 **“中间人攻击”** 并提供不可否认性。
> 4.  **综合应用 (安全电子邮件)**：
>     * 这是本章知识的**集大成者**。请重点理解“**混合加密**”（用公钥加密会话密钥 + 用会话密钥加密正文）与“**数字签名**”（先哈希再私钥加密）是如何结合的。

## 第 8 章：网络安全 (Chapter 8: Network Security)

### 8.1 什么是网络安全？(What is Network Security?)

网络安全的核心属性包括：
* **机密性 (Confidentiality):** 只有发送方和预期的接收方能够理解消息内容。
    * 实现方式：发送方加密 (encrypts)，接收方解密 (decrypts)。
* **身份认证 (Authentication):** 发送方和接收方确认彼此的真实身份。
* **消息完整性 (Message Integrity):** 确保消息在传输过程中未被篡改（未被修改、删除或添加）。
* **访问与可用性 (Access and Availability):** 服务必须对授权用户是可访问和可用的。

**网络中的角色：**
* **Alice & Bob:** 通信双方（好人）。
* **Trudy (Intruder):** 入侵者（坏人）。
    * **攻击手段：**
        * **窃听 (Eavesdrop):** 拦截消息。
        * **插入 (Insert):** 主动在连接中插入消息。
        * **伪装 (Impersonation):** 伪造源地址或数据包字段。
        * **劫持 (Hijacking):** 接管正在进行的连接。
        * **拒绝服务 (Denial of Service):** 通过过载资源阻止服务。

---

### 8.2 密码学原理 (Principles of Cryptography)

#### 1. 密码学术语
* **明文 (Plaintext, $m$):** 原始消息。
* **密文 (Ciphertext, $K(m)$):** 加密后的消息。
* **密钥 (Key, $K$):** 加密和解密算法使用的参数。
* **加密算法 (Encryption Algorithm):** 将明文转换为密文。
* **解密算法 (Decryption Algorithm):** 将密文还原为明文。

#### 2. 传统加密方法

* **替换密码 (Substitution Cipher):** 将一个东西替换为另一个。
    * **单表替换密码 (Monoalphabetic Cipher):** 每个字母替换为唯一的另一个字母（例如凯撒密码）。易受**统计分析 (Statistical Analysis)** 攻击（根据字母频率）。
* **多表加密 (Polyalphabetic Encryption):** 使用多个单表密码并按某种模式循环使用，以提高安全性。

#### 3. 对称密钥密码学 (Symmetric Key Cryptography)

##### 核心：块密码 (Block Ciphers)
块密码是现代加密技术的基础。
* **基本原理**：
    * 将明文消息分割成固定大小的块（例如 64 位或 128 位）。
    * 使用 **1 对 1 的映射**，将 $k$ 位的明文块转换为 $k$ 位的密文块。
    * **实现机制**：由于直接查表（需要 $2^{64}$ 个条目）太大不可行，实际通过函数模拟随机排列。通常采用 **多轮 (Rounds)** 迭代结构，每一轮使用密钥的不同部分进行运算，使得输入的一个比特能影响输出的多个比特，从而充分打乱数据。

##### A.  数据加密标准  （Data Encryption Standard DES）

DES 是最著名的**对称密钥块密码**，虽然已被 AES 取代，但其设计思想（Feistel 结构）仍是密码学的经典教材。

* **核心结构：Feistel 网络**
    * **特点**：设计非常谨慎，每一轮**只处理一半数据**。
    * **优势**：解密过程和加密过程极其相似，只需逆序使用子密钥，硬件实现极其容易。

* **输入 (Input)**：64 位明文块 (Block Size)。
* **密钥 (Key)**：56 位有效密钥 (通常存储为 64 位，其中 8 位用于奇偶校验)。
* **轮数 (Rounds)**：**16 轮** 相同的迭代处理。


DES 首先进行初始置换 (IP)，然后进入 16 轮迭代。每一轮主要处理**右半部分 ($R$)**，左半部分 ($L$) 在该轮保持静止。

1.  **左右切分 (Split)**：
    * 将 64 位数据切分为左右两半：$L_0$ (32位) 和 $R_0$ (32位)。
2.  **轮函数 $f$ (针对右半部分 $R$ )**：
    * **扩展 (Expansion)**：将 32 位 $R$ 通过扩展置换变为 **48 位**。
        * *目的*：增加雪崩效应，并匹配子密钥长度。
    * **密钥混合 (Key Mixing)**：将扩展后的 48 位数据与当轮的 **48 位子密钥** 进行 **异或 ($\oplus$)**。
    * **替换 (Substitution) - S-盒 (S-Box)**：**【核心步骤】**
        * 将 48 位数据分成 8 组（每组 6 位），查 8 个不同的 S-盒表，输出 32 位（每组 4 位）。
        * *目的*：引入**非线性 (Non-linearity)**。这是 DES 安全性的根本，切断了输入输出的线性联系，用于实现**混淆 (Confusion)**。
    * **置换 (Permutation) - P-盒 (P-Box)**：
        * 将 S-盒输出的 32 位数据打乱顺序。
        * *目的*：实现**扩散 (Diffusion)**，让一位的变化在下一轮扩散到更多位置。
3.  **合并与交换 (XOR & Swap)**：
    * 将轮函数 $f$ 的输出与左半部分 $L$ 进行 **异或**。
    * **交换**：原来的 $R$ 变成下一轮的 $L$，运算结果变成下一轮的 $R$。
    * *公式*：$L_{i} = R_{i-1}$，$R_{i} = L_{i-1} \oplus f(R_{i-1}, K_i)$。


* **安全性较低**：主要弱点是 **56 位密钥空间太小** ($2^{56}$)。
    * 现代算力可以通过**暴力破解 (Brute-force attack)** 在不到 24 小时内遍历所有密钥。
* **改进方案：3DES (Triple DES)**
    * **原理**：使用 3 个不同的密钥 ($K_1, K_2, K_3$) 进行三次操作。
    * **流程**：加密 ($K_1$) $\rightarrow$ 解密 ($K_2$) $\rightarrow$ 加密 ($K_3$)。
    * *注：中间使用“解密”是为了兼容老式 DES 硬件（当 $K_1=K_2=K_3$ 时等同于单次 DES）。*
    * **效果**：虽然速度慢，但大幅增加了密钥空间，延长了算法寿命。

##### B. AES (高级加密标准)

* **地位**：2001 年推出的新标准，旨在替代 DES。
* **参数**：
    * **输入**：处理 **128 位** 的数据块。
    * **密钥**：支持 **128、192 或 256 位** 密钥。
* **加密效果与安全性**：
    * **极高安全性**：相比于 DES 极易被破解，AES 的暴力破解预计需要 **149 万亿年**，是目前最安全的对称加密标准之一。


AES 不同于 DES 的 Feistel 结构（左右互搏），它使用 **SPN (Substitution-Permutation Network)** 结构。它将 128 位数据看作一个 **$4 \times 4$ 的字节矩阵 (State)**，每一轮都对所有字节进行并行处理。

**每一轮 (Round) 的四个标准步骤：**
1.  **字节代换 (SubBytes) 
    * **动作**：查表（S-盒）。把矩阵中每个格子里的字节，独立替换成 S-盒中对应的另一个字节。
    * **目的**：这是唯一的**非线性**步骤，彻底打乱数据内容，切断输入输出的线性联系。
2.  **行移位 (ShiftRows) 
    * **动作**：每一行向左循环移动不同的偏移量（第 1 行不动，第 2 行移 1 格...）。
    * **目的**：**横向打乱**。把原本属于某一列的数据“搬运”到其他列。
3.  **列混合 (MixColumns) **
    * **动作**：矩阵运算。对每一列的 4 个字节进行线性组合（混合）。
    * **目的**：**纵向打乱**。确保输入的一个字节变化能影响到这一列的所有字节。
    * *注：结合 ShiftRows，经过几轮后，1 个比特的变化就能扩散到整个矩阵。*
4.  **轮密钥加 (AddRoundKey) 
    * **动作**：将当前矩阵与当轮的子密钥进行 **异或 ($\oplus$)**。
    * **目的**：将密钥的秘密信息注入数据中。


##### C. CBC (密码块链接模式)
单纯使用块密码（ECB 模式）存在缺陷：相同的明文块会生成相同的密文块，容易被统计分析攻击。CBC 模式解决了这个问题。

* **核心机制**：引入随机性与依赖性。
* **加密流程**：
    * 当前明文块 $m(i)$ 在加密前，先与**前一个密文块** $c(i-1)$ 进行 **异或 ($\oplus$)** 运算。
    * **公式**：$c(i) = K_s(m(i) \oplus c(i-1))$。
* **解密流程**：
    * 先解密当前密文块，再与前一个密文块异或恢复明文。
    * **公式**：$m(i) = K_s(c(i)) \oplus c(i-1)$。
* **初始化向量 (IV)**：
    * 对于第一个块（没有前一个密文），使用一个随机生成的块 $c(0)$ 作为 **IV**。
    * **效果**：IV 不需要保密，但必须随机。这保证了即使**完全相同的消息**，只要 IV 不同，每次加密生成的**密文也会完全不同**。

CBC (密码块链接) 的核心目的是**打破明文块之间的独立性**，防止同样的明文生成同样的密文（即解决 ECB 模式的缺陷）。

**1. 核心逻辑：连锁反应 (Chaining)**
* 每一块数据的加密，都依赖于**前一块的密文**。这使得加密过程具有了“记忆性”。

**2. 加密过程 (Encryption)**
* **公式**：$C_i = E_K(P_i \oplus C_{i-1})$
* **步骤**：
    1.  拿到当前明文块 $P_i$。
    2.  先将其与**前一个密文块 $C_{i-1}$** 进行 **异或 ($\oplus$)**。
    3.  将异或后的结果送入 AES/DES 进行加密，得到当前密文 $C_i$。
* **第一块怎么办？** 使用一个随机生成的 **IV (初始化向量)** 充当 $C_0$。

**3. 解密过程 (Decryption)**
* **公式**：$P_i = D_K(C_i) \oplus C_{i-1}$
* **步骤**：
    1.  先将当前密文 $C_i$ 送入 AES/DES 进行解密。
    2.  将解密出的中间结果与**前一个密文块 $C_{i-1}$** 进行 **异或 ($\oplus$)**。
    3.  还原出明文 $P_i$。

**4. 为什么需要 IV (Initialization Vector)？**
* **随机化**：IV 保证了即使明文完全相同（例如两次都发送 "Hello"），只要 IV 不同，生成的密文流就会**截然不同**。
* **防重放**：攻击者无法通过观察密文判断你是否发送了重复的消息。


#### 4. 公钥密码学 (Public Key Cryptography)

公钥密码学（又称非对称密码学）解决了对称密钥加密中“密钥分发”的难题。

* **基本特点：**
    * **密钥对 (Key Pair):** 每个通信实体（例如 Bob）都拥有一对密钥，而不是一个共享密钥。
        * **公钥 (Public Key, $K_B^+$):** 公开给所有人，世界上的任何人都可以使用它来给 Bob **加密**消息。
        * **私钥 (Private Key, $K_B^-$):** 只有 Bob 自己知道，用于**解密**收到的消息。
    * **分离的加解密能力：** 即使你知道加密密钥（公钥），你也无法解密消息；只有拥有私钥的人才能解密。

* **核心要求：**
    1.  **可逆性：** 使用公钥加密后，必须能使用私钥解密还原。即：$K_B^-(K_B^+(m)) = m$。
    2.  **计算安全性：** 即使已知公钥 $K_B^+$ 和加密算法，在计算上应该**无法推导出**私钥 $K_B^-$。

##### **RSA 算法详解：原理与推导**

RSA 是目前最流行、使用最广泛的公钥算法，其安全性基于**大整数分解**的数学难题。

**1. 预备知识：模运算 (Modular Arithmetic)**

RSA 的核心依赖于模运算的以下性质：
* **加法与乘法封闭性：** 模运算下的加减乘操作是封闭的。
* **指数运算性质：** $(a \mod n)^d \mod n = a^d \mod n$。
* **欧拉定理推论 (关键事实)：** 对于 $n=pq$ 和 $z=(p-1)(q-1)$，有 $x^y \mod n = x^{(y \mod z)} \mod n$。

**2. RSA 密钥生成步骤 (Key Generation)**

Alice 和 Bob 需要通过以下步骤生成公钥和私钥：

1.  **选择素数：** 选择两个极大的素数 $p$ 和 $q$（例如每个 1024 位）。
2.  **计算模数：** 计算 $n = p \times q$。
3.  **计算欧拉函数值：** 计算 $z = (p-1)(q-1)$。
4.  **选择公钥指数 $e$：** 选择一个整数 $e$，满足 $e < n$ 且 $e$ 与 $z$ **互质**（即没有公因数）。
5.  **计算私钥指数 $d$：** 寻找一个整数 $d$，使得 $e \times d - 1$ 能被 $z$ 整除。
    * 即满足同余方程：**$ed \equiv 1 \pmod z$**。
6.  **结果：**
    * **公钥 (Public Key)：** $(n, e)$
    * **私钥 (Private Key)：** $(n, d)$

**3. 加密与解密过程**

假设发送方要发送的消息比特模式表示为整数 $m$（需满足 $m < n$）。

* **加密 (Encryption)：** 使用接收方的公钥 $(n, e)$。
    $$c = m^e \mod n$$
* **解密 (Decryption)：** 使用接收方的私钥 $(n, d)$。
    $$m = c^d \mod n$$

**4. 正确性推导 (为什么解密能还原明文？)**

我们需要证明：使用私钥解密密文 $c$，确实能得到原始消息 $m$。
即证明：**$(m^e)^d \mod n = m$**，这是由欧拉定理保证的。

> [!NOTE] 核心理论：欧拉定理 (Euler's Theorem) 与 RSA 的数学基石
>
> **1. 定理定义**
> 若 $n, a$ 为正整数，且 $\gcd(a, n) = 1$（即 $a, n$ 互质），则：
> $$a^{\phi(n)} \equiv 1 \pmod n$$
> 其中 $\phi(n)$ 是欧拉函数。对于 RSA 算法中的 $n = p \times q$，有 **$\phi(n) = (p-1)(q-1)$**。
>
> **2. 在 RSA 中的推导 (通用情况: $\gcd(m, n) = 1$)**
> RSA 的密钥生成要求 $e$ 和 $d$ 满足：$ed \equiv 1 \pmod{\phi(n)}$。
> 这意味着存在整数 $k$，使得 **$ed = k \cdot \phi(n) + 1$**。
>
> 根据欧拉定理，我们可以推导出解密的正确性：
> $$
> \begin{aligned}
> m^{ed} \pmod n &= m^{k \cdot \phi(n) + 1} \pmod n \\
> &= (m^{\phi(n)})^k \cdot m \pmod n \\
> &= (1)^k \cdot m \pmod n \\
> &= m
> \end{aligned}
> $$
>
> **3. 特殊情况说明：若 $\gcd(m, n) \neq 1$ 怎么办？**
> 标准的欧拉定理证明确实要求互质，但在 RSA 体系中（$n=pq$），即使 $m$ 和 $n$ **不互质**，解密公式 **$m^{ed} \equiv m \pmod n$ 依然成立**。
> * **数学保障：** 通过中国剩余定理和费马小定理可以证明，分别在 $\pmod p$ 和 $\pmod q$ 下等式恒成立，因此在 $\pmod n$ 下也成立。
> * **安全说明**：如果发现 $\gcd(m, n) = d$ 且 $d > 1$， 这意味着你直接**分解了 $n$**。一旦 $n$ 被分解，你就可以算出 $\phi(n)$，进而算出私钥 $d$。
>
> **4. 关键结论 **
> 在 RSA 的模幂运算体系中，必须区分两个“世界”：
> * **底数世界 (加密/解密数据)：** 所有的 $m$ 和 $c$ 都是在 **$\pmod n$** 下运算的。
> * **指数世界 (生成密钥)：** 所有的指数 $e$ 和 $d$ 都是在 **$\pmod{\phi(n)}$** 下运算的。

##### RSA性质

* **重要性质 (用于数字签名)：**
    * RSA 的密钥使用顺序是可以**交换**的。
    * **先加密后解密：** $K_B^-(K_B^+(m)) = m$ （用于保密通信）。
    * **先解密后加密：** $K_B^+(K_B^-(m)) = m$ （用于数字签名）。
    * 这意味着：如果你用私钥处理一个消息，任何人都可以用你的公钥“还原”它。因为只有你拥有私钥，这就证明了消息是你发送的。

* **会话密钥 (Session Keys)：**
    * **问题：** RSA 的指数运算在计算上非常昂贵，比对称加密（如 DES/AES）慢 100 到 10000 倍。
    * **解决方案：** 混合使用。
        1.  Alice 生成一个临时的、只用一次的对称密钥 $K_s$（称为**会话密钥**）。
        2.  Alice 使用 Bob 的公钥加密这个短小的 $K_s$，发送给 Bob。
        3.  Bob 用私钥解密得到 $K_s$。
        4.  双方使用 $K_s$ 和高效的对称加密算法（如 AES）进行大量数据的传输。

### 8.3 消息完整性 (Message Integrity)

仅有加密无法保证完整性（Trudy 可以修改密文）。需要机制来验证内容未被篡改且来源可信。

#### 1. 消息摘要 (Message Digest) / 哈希函数 (Hash Function)
* **定义：** 将任意长度的消息 $m$ 映射为固定长度的字符串 $H(m)$。
* **特性：**
    * **多对一：** 不同的消息可能产生相同的哈希（冲突）。
    * **单向性 (Irreversibility):** 无法从 $H(m)$ 反推 $m$。
    * **抗冲突 (Collision Resistance):** 极难找到两个不同的消息 $x, y$ 使得 $H(x) = H(y)$。
* **算法：** MD5 (128位，已不推荐), SHA-1 (160位)。
* **互联网校验和 (Checksum):** 也是一种哈希，但安全性差，容易构造冲突。

#### 2. 消息认证码 (MAC - Message Authentication Code)

仅仅使用哈希函数只能保证数据没有被意外篡改，但无法防止恶意篡改（攻击者可以修改消息并重新计算哈希）。为了同时实现**完整性**和**发送方认证**，我们需要引入一个**共享秘密 (Shared Secret)**。

* **核心定义：**
    * MAC 也被称为“带密钥的哈希” (Keyed Hash)。
    * 它不需要加密算法，而是依赖哈希函数 $H()$ 和一个只有通信双方（例如 Alice 和 Bob）知道的密钥字符串 $s$。

* **工作原理：**
    1.  **发送方 (Alice)：**
        * 准备好要发送的消息 $m$。
        * 将共享秘密 $s$ 与消息 $m$ 拼接在一起，计算其哈希值：$H(s + m)$。
        * 这个生成的哈希值就是 **MAC**（或称为消息摘要 $MD_m$）。
        * Alice 将 **原始消息 $m$** 和 **MAC** 一起发送给 Bob（通常表示为 $m || MAC$）。
        * *注意：消息本身通常是不加密的，以明文形式传输。*
    2.  **接收方 (Bob)：**
        * 收到消息 $m'$ 和附带的 MAC'。
        * 由于 Bob 知道共享秘密 $s$，他使用本地的 $s$ 和收到的消息 $m'$ 进行同样的哈希计算：$H(s + m')$。
        * **比较：** Bob 将自己计算出的结果与收到的 MAC' 进行比对。
    3.  **验证结论：**
        * 如果两者**一致**：Bob 可以确信消息在传输过程中未被篡改（完整性），且消息一定是由知道秘密 $s$ 的人（Alice）生成的（认证）。
        * 如果两者**不一致**：说明消息被篡改了，或者发送者不知道秘密 $s$，Bob 丢弃该消息。

* **HMAC (Hash-based Message Authentication Code)：**
    * 这是目前广泛使用的 MAC 标准。
    * **背景：** 简单的直接拼接 $H(s + m)$ 存在一些微妙的安全缺陷（如长度扩展攻击）。
    * **改进机制：** HMAC 采用**嵌套哈希**的方式来增强安全性。
        * 它不只是哈希一次，而是进行两轮哈希运算。
        * 大致逻辑：先把密钥和消息哈希一次，然后把密钥和上一步的哈希结果再哈希一次。
        * *步骤简述：*
            1.  将密钥拼接在消息前面。
            2.  对拼接结果进行哈希。
            3.  将密钥再次拼接在上述哈希摘要的前面。
            4.  对这个新组合再次进行哈希，得到最终结果。

* **典型应用案例：OSPF 路由协议**
    * OSPF 是自治系统内部的路由协议。为了防止恶意攻击者注入错误的路由信息（如消息插入、删除或修改），路由器之间需要验证 OSPF 更新包的真实性。
    * **实现：** 路由器之间共享一个密码（Secret）。在发送 OSPF 报文时，路由器计算报文内容与密码的 MD5 哈希值，并将这个哈希值附加在 OSPF 报文的尾部。接收方路由器通过验证哈希值来确认报文确实来自可信的邻居且未被篡改。

### 8.3.2 身份认证 (Authentication)

#### 演进过程：
* **ap1.0:** "我是 Alice"。 -> 失败（Trudy 也可以这么说）。
* **ap2.0:** "我是 Alice" (在 IP 包中)。 -> 失败（Trudy 可以伪造 IP 源地址）。
* **ap3.0:** "我是 Alice" + 密码。 -> 失败（Trudy 可以窃听密码并重放 - **重放攻击 Playback Attack**）。
* **ap3.1:** "我是 Alice" + 加密密码。 -> 失败（Trudy 仍然可以录制加密后的密码并重放）。
* **ap4.0:** **Nonce (一次性随机数)**。
    * Bob 发送一个随机数 $R$ (Nonce) 给 Alice。
    * Alice 用共享密钥加密 $R$ 并发回。
    * Bob 解密验证。防止了重放攻击（因为每次 $R$ 都不同）。
* **ap5.0:** Nonce + 公钥。
    * Alice 用私钥加密 Nonce。存在**中间人攻击**风险（如果 Bob 没有正确验证 Alice 的公钥）。

#### 3. 数字签名 (Digital Signatures)
* **目的：** 提供**不可否认性 (Non-repudiation)**。证明消息确实由某人发送，且只有他能发送。
* **实现：** 使用**私钥加密**。
    * Bob 对消息 $m$ 的哈希值 $H(m)$ 用自己的**私钥 $K_B^-$** 进行加密，生成签名。
    * Alice 收到后，用 Bob 的**公钥 $K_B^+$** 解密签名得到 $h$，同时计算收到消息的哈希 $H(m')$。如果 $h = H(m')$，则签名有效。

#### 4. 公钥认证 (Public-Key Certification)

* **问题：** 即使使用了公钥，怎么知道公钥真的属于 Bob 而不是冒充者 Trudy？（中间人攻击 Man-in-the-Middle Attack）。
* **解决方案：认证中心 (CA - Certification Authority)**。
    * CA 是可信赖的第三方。
    * CA 将实体（如 Bob）的身份与其公钥绑定，并用 **CA 的私钥**对这些信息进行签名，生成**证书 (Certificate)**。
    * 用户通过 CA 的公钥（预装在浏览器/OS中）验证证书的合法性，从而获得可信的 Bob 公钥。


---

### 8.4 安全电子邮件 (Securing E-mail)

在实际的电子邮件安全协议（如 PGP - Pretty Good Privacy）中，为了同时实现机密性、完整性和身份认证，通常结合使用**公钥加密**、**对称加密**和**哈希函数**。

#### 1. 机密性 (Confidentiality)

为了保证邮件内容只有接收方 (Bob) 能看懂，需要对邮件进行加密。由于公钥算法（如 RSA）计算极其复杂、速度慢，不适合直接加密长邮件，因此采用**混合加密机制**。

<img src="Chapter8_part1.pdf#page=75&rect=16,159,706,435" alt="Chapter8_part1, p.75">

* **核心思想**：利用对称加密的高效率来加密正文，利用公钥加密的便捷性来分发对称密钥。
* **具体步骤**：
    1.  **生成会话密钥**：Alice 生成一个临时的、随机的对称会话密钥 $K_S$ (Session Key)。
    2.  **加密邮件**：使用 $K_S$ 对邮件正文 $m$ 进行加密，生成密文 $K_S(m)$。
    3.  **加密密钥**：使用 Bob 的公钥 $K_B^+$ 对这个短小的会话密钥 $K_S$ 进行加密，生成 $K_B^+(K_S)$。
    4.  **发送**：将“加密后的密钥”和“加密后的邮件”组合发送。
* **优势**：既保证了安全性（只有 Bob 的私钥能解开 $K_S$），又保证了性能（邮件正文使用高速的对称加密）。

#### 2. 发送方认证与完整性 (Authentication & Integrity)
为了防止邮件被篡改（完整性），并确保邮件确实是 Alice 发送的（源认证），使用**数字签名**技术。

<img src="Chapter8_part1.pdf#page=77&rect=14,136,708,435" alt="Chapter8_part1, p.77">

* **核心思想**：对邮件的“指纹”（哈希摘要）进行加密，而不是对整个邮件签名，以提高效率。
* **具体步骤**：
    1.  **计算摘要**：Alice 使用哈希函数（如 MD5 或 SHA）对邮件 $m$ 计算得到固定长度的报文摘要 $H(m)$。
    2.  **数字签名**：Alice 使用**自己的私钥** $K_A^-$ 对摘要进行加密，生成签名 $K_A^-(H(m))$。
    3.  **发送**：将原始邮件 $m$ 与数字签名拼接在一起发送。
* **验证原理**：Bob 收到后，用 Alice 的公钥 $K_A^+$ 解密签名得到摘要 $H$，并自己计算邮件的哈希 $H'$。如果 $H = H'$，则证明邮件未被修改且确实来自 Alice。

#### 3. 综合方案：先签名，后加密 (The Combined Scheme)
在实际应用中，Alice 希望同时实现上述所有目标。通常遵循 **“先签名，后加密”** 的顺序。

<img src="Chapter8_part1.pdf#page=78&rect=29,103,686,438" alt="Chapter8_part1, p.78">

**发送方 (Alice) 的操作流程：**
1.  **签名**：
    * 计算邮件 $m$ 的哈希 $H(m)$。
    * 用 Alice 的私钥签名：$Sig = K_A^-(H(m))$。
    * 将签名附在邮件后，形成组合体 $[m + Sig]$。
2.  **加密**：
    * 生成临时会话密钥 $K_S$。
    * 用 $K_S$ 加密整个组合体（邮件+签名）：$EncryptedData = K_S(m + Sig)$。
    * 用 Bob 的公钥加密会话密钥：$EncryptedKey = K_B^+(K_S)$。
3.  **发送**：发送 $EncryptedKey$ 和 $EncryptedData$。

**接收方 (Bob) 的操作流程：**
1.  **提取密钥**：用 Bob 的私钥 $K_B^-$ 解密 $EncryptedKey$，拿到会话密钥 $K_S$。
2.  **解密数据**：用 $K_S$ 解密 $EncryptedData$，还原出 $[m + Sig]$。
3.  **验证签名**：
    * 分离出邮件 $m$ 和签名 $Sig$。
    * 用 Alice 的公钥 $K_A^+$ 解密 $Sig$，得到原始摘要 $H(m)$。
    * 对解密出的邮件 $m$ 重新计算哈希 $H'(m)$。
    * **比对**：若 $H(m) == H'(m)$，则所有安全目标达成。

$$
\begin{aligned}
\text{Alice Sends: } & \underbrace{K_B^+(K_S)}_{\text{数字信封}} + \underbrace{K_S(\overbrace{m}^{\text{邮件}} + \overbrace{K_A^-(H(m))}^{\text{数字签名}})}_{\text{加密载荷}}
\end{aligned}
$$