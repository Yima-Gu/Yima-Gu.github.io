---
title: Network - 03.Network Layer-02
date: 2026-01-15 11:05:00 +0800
tags:
    - Network
categories:
    - Network
math: true
syntax_converted: true
---


{% note success '' %}
**路由算法 (Routing Algorithms)**
* **核心目标：** 在网络中找到从源到目的地的**最低成本路径**。
* **抽象模型：** 使用图论 $G=(N, E)$ 来建模网络，其中 $N$ 是路由器，$E$ 是链路，$c(x,x')$ 是链路成本。
* **分类：**
    * **按信息范围：**
        * **全局 (LS)：** 所有路由器拥有完整的拓扑和成本信息（如 **OSPF**）。使用 **Dijkstra 算法**。
        * **分散 (DV)：** 路由器只知道邻居信息，通过迭代交换信息（如 **RIP**）。使用 **Bellman-Ford 方程**。
    * **按更新时机：** 静态（变化慢）与动态（变化快）。

**链路状态 (LS) 路由**
* **算法：** Dijkstra 算法，计算从一个源到所有节点的最低成本路径。
* **特点：** 需要全网广播链路状态信息。
* **问题：** 可能发生**路由震荡**，尤其是在成本与流量相关时。

**距离向量 (DV) 路由**
* **算法：** 基于 Bellman-Ford 方程的迭代、异步、分布式算法。
* **特点：** 节点只维护到所有目的地的成本估计（距离向量），并与邻居交换。
* **问题：** **坏消息传得慢**，可能导致路由环路（**计数到无穷**）。解决方案包括**毒性逆转**。

**互联网中的路由**
* **分层结构：** 由于互联网规模巨大且管理自治，采用**分层路由**，将路由器组织成**自治系统 (AS)**。
* **AS 内部路由 (IGP)：** 在同一个 AS 内部运行，目标是找到最优路径。
    * **RIP：** 简单的 DV 协议，基于跳数，每 30 秒广播。
    * **OSPF：** 开放的 LS 协议，使用 Dijkstra，直接承载在 IP 上，支持分层（区域）。
* **AS 间路由 (EGP)：** 在不同 AS 之间运行，目标是找到可达且符合策略的路径。
    * **BGP：** 事实上的标准，基于路径向量，通过 TCP 会话（eBGP/iBGP）交换可达信息，并根据策略进行路由选择。

**软件定义网络 (SDN)**
* **核心思想：** **控制平面与数据平面分离**。控制平面是逻辑上集中的远程**控制器 (软件)**，数据平面是简单的**交换机硬件**。
* **优势：** 易于管理、开放性、灵活的流量工程。
* **架构：**
    1.  **应用层：** 实现网络功能（路由、防火墙等）。
    2.  **控制器层：** 维护网络状态，提供北向和南向 API。
    3.  **基础设施层：** 数据平面交换机，根据**流表**转发。
* **OpenFlow：** 事实上的标准**南向接口**协议。核心是基于**流表**的**广义转发**（匹配+动作），统一了路由器、交换机、防火墙等设备的功能。
* **本质：** 通过软件定义和可编程性，解耦软硬件，实现网络的深度可编程。
{% endnote %}


### 4.5 路由算法 (Routing Algorithms)

 1. **图抽象 (Graph Abstraction)**
	* 路由问题可以抽象为图论问题。
	* **图 (Graph):** $G=(N, E)$
	* **N = 节点/路由器 (Nodes/Routers):** 集合 $\{u, v, w, x, y, z\}$
	* **E = 链路 (Edges/Links):** 路由器之间的连接，例如 $\{(u,v), (u,x), ...\}$
	* **链路成本 (Link Cost):** $c(x, x')$
	    * 可以是 1（即计算跳数），也可以与带宽 (bandwidth) 或拥塞 (congestion) 程度成反比。
	* **路径成本 (Path Cost):** 路径上所有链路成本的总和。
	* **路由算法 (Routing Algorithm):** 找到源和目标之间的**最低成本路径 (least-cost path)**。

 2. **路由算法分类 (Classification)**
	**按信息范围：**
	-   **全局 (Global) 算法 (又称: 链路状态 LS):**
	    * 所有路由器拥有完整的**拓扑 (topology)** 和链路成本信息。
	    * 例如：**链路状态 (Link State, LS) 算法**。
	-   **分散 (Decentralized) 算法 (又称: 距离向量 DV):**
	    * 路由器只知道其物理连接的邻居和到邻居的链路成本。
	    * 通过迭代计算和与邻居交换信息来工作。
	    * 例如：**距离向量 (Distance Vector, DV) 算法**。
	**按更新时机：**
	-   **静态 (Static):** 路由变化缓慢。
	-   **动态 (Dynamic):** 路由变化迅速，可能是周期性更新或在链路成本变化时触发。


#### 4.5.1 链路状态 (Link State, LS) 路由算法

链路状态算法是一种**全局性 (Global)** 路由算法，要求网络中的每个节点在计算路径前，都必须掌握完整的网络拓扑结构和所有链路的成本 (Link Cost)。

##### 1. 狄克斯特拉算法 (Dijkstra's Algorithm)

这是 LS 路由最核心的算法，用于计算从一个**源节点 (Source Node)** 到网络中所有其他节点的**最低成本路径 (Least-cost Path)**。

**算法符号定义：**
* **$c(x, y)$**：从节点 $x$ 到节点 $y$ 的**直接**链路成本；如果不直接相连，则成本为 $\infty$。
* **$D(v)$**：从源节点到目的节点 $v$ 的**当前**路径成本。
* **$p(v)$**：从源到 $v$ 的当前最低成本路径中，$v$ 的**前驱节点 (Predecessor)**。
* **$N'$**：当前已确定最低成本路径的节点集合。

**算法执行步骤：**

1. **初始化 (Initialization)**：
    * $N' = \{u\}$（$u$ 为源节点）。
    * 对于所有节点 $v$：
        * 如果 $v$ 是 $u$ 的邻居，则 $D(v) = c(u, v)$。
        * 否则，$D(v) = \infty$。
2. **循环 (Loop)**：
    * 在所有不在 $N'$ 中的节点中，找到一个具有最小当前成本 $D(w)$ 的节点 $w$。
    * 将 $w$ 加入集合 $N'$。
    * **更新 (Update)**：对于 $w$ 的所有不在 $N'$ 中的邻居 $v$，更新其成本：
        $D(v) = \min( D(v), D(w) + c(w, v) )$。
        * *含义：新成本是原到 $v$ 的成本与“经过 $w$ 到达 $v$ 的成本”之间的最小值*。
3. **终止**：当所有节点都已加入 $N'$ 时，算法结束。
##### 2. 算法复杂度与特性

* **计算复杂度 (Computational Complexity)**：
    * 对于拥有 $n$ 个节点的网络，算法需要进行 $n$ 次迭代。
    * 每一轮迭代都需要搜索不在 $N'$ 中的节点以寻找最小值。
    * 总搜索次数为 $n(n+1)/2$，即算法复杂度为 **$O(n^2)$**；若使用高效实现（如堆排序），可优化至 **$O(n \log n)$**。
* **报文复杂度 (Message Complexity)**：
    * 每个节点必须通过**链路状态广播 (Link State Broadcast)** 向全网所有其他节点发送其链路信息。
    * 发送的消息数量级通常与节点数 $n$ 和链路数 $E$ 相关。

##### 3. LS 算法的问题：路由震荡 (Oscillations)

如果链路成本是基于流量负载 (Load-sensitive) 定义的，LS 算法可能会导致**路由震荡 (Oscillations)**。

**震荡过程示例：**
1. 假设路径 A 流量较轻，成本低，所有路由器计算后将流量全部切向 A。
2. 由于所有流量都涌向 A，导致路径 A 变得极度拥塞，成本大幅上升。
3. 在下一次算法计算中，路由器发现路径 B 的成本相对变低，于是所有流量又同时切向 B。
4. 这种在不同路径间**集体“跳跃”的行为即为震荡**。

**解决方案：**

如果所有路由器都在**同一时间间隔**（例如每 30 秒）同步运行 Dijkstra 算法，它们会看到完全相同的“低成本”路径，并做出完全相同的决定。这种**一致性的行为**导致了流量的剧烈波动。

为了打破这种“集体行动”，通常采用以下策略：
* **计算时间随机化 (Randomize Algorithms Execution)**： 
	* 这是最实用的方案。通过让每个路由器运行 Dijkstra 算法的时间点**随机错开**，可以保证每次只有一部分路由器在改变路由决策。这样，流量会逐步、零散地向更优路径迁移，网络更有可能达到一个稳定的平衡点，而不是在两个极端间震荡。 
* **平滑成本权重**： 避免链路成本对流量变化过于敏感。例如，不直接使用瞬时负载，而是使用长期平均负载来计算成本，从而过滤掉短期波动对路由的影响。

#### 4.5.2 距离向量 (Distance Vector, DV) 路由

距离向量算法是一种**迭代的 (Iterative)**、**分布式的 (Distributed)** 且**异步的 (Asynchronous)** 算法。与链路状态 (LS) 算法不同，它不需要节点了解全局网络拓扑，节点只需与邻居交换信息即可。

##### 1. 贝尔曼-福特方程 (Bellman-Ford Equation)

这是 DV 算法的数学核心，利用了动态规划的思想。

**方程表达式：**
$d_x(y) = \min_v \{ c(x,v) + d_v(y) \}$

**符号含义：**
* **$d_x(y)$**：从源节点 $x$ 到目的节点 $y$ 的最低路径成本估计。
* **$v$**：$x$ 的所有直连邻居。
* **$c(x,v)$**：从 $x$ 到邻居 $v$ 的**直接**链路成本。
* **$d_v(y)$**：从邻居 $v$ 到目的节点 $y$ 的最低路径成本估计。

**逻辑：** 节点 $x$ 遍历所有邻居 $v$，计算“到邻居 $v$ 的成本”与“从 $v$ 到 $y$ 的剩余成本”之和，取其中的最小值。

##### 2. **路由器的内部存储结构：距离向量表**

- 在 DV 算法中，每个节点 $x$ 实际上维护的是一个**二维矩阵（或多个向量的集合）**。
	- **自己的距离向量 ($D_x$)**：这是一个一维数组，存储着节点 $x$ 认为到网络中所有目的地 $y$ 的**当前最小成本**。这是节点 $x$ 对外通告的内容。
	- **邻居的距离向量库 ($D_v$)**：节点 $x$ 会为每一个直接相连的邻居 $v$ 开辟一块空间，专门记录邻居 $v$ 上一次发过来的距离向量。	    
	- _注意_：这反映了“邻居认为它到目的地的距离”。
	- **本地链路成本 ($c(x,v)$)**：节点 $x$ 知道自己到所有直接邻居 $v$ 的物理链路成本。

##### 3. **详细的维护流程：三阶段迭代**

1. 第一阶段：**等待** (Wait)
	- 路由器大部分时间处于“休眠”状态，直到以下两种**事件**之一发生：
		-  **本地链路成本变化**：节点 $x$ 发现到某个邻居 $v$ 的物理链路变快了、变慢了或断开了。
		- **收到邻居的更新报文**：邻居 $v$ 发送了它最新的距离向量 $D_v$ 过来。
2. 第二阶段：**重新计算** (Recompute) —— 执行Bellman-Ford方程
	- 这是最核心的维护步骤。每当上述事件发生，节点 $x$ 就会重新计算它到所有目的地 $y$ 的最小成本 $d_x(y)$。
	- 计算逻辑如下：
		- 对于每一个目的地 $y$，节点 $x$ 会扫描它所有的邻居 $v$，并计算：$$d_x(y) = \min_{v} \{ c(x,v) + d_v(y) \}$$
		- $c(x,v)$ 是我到邻居的距离（本地已知）。
		- $d_v(y)$ 是邻居上次告诉我的，它到目的地的距离（从缓存中取）。
	- **结果**：节点 $x$ 选出那个能让总和最小的邻居 $v$，作为通往 $y$ 的**下一跳 (Next Hop)**，并更新自己的 $D_x(y)$。
3. 第三阶段：**通知** (Notify) —— 增量传播
	- **触发条件**：只有当节点 $x$ 重新计算后的 $D_x$ 发生了**变化**（即发现了一条更优路径或原路径变差了），它才需要行动。
	- **动作**：将更新后的 $D_x$ 向量（包含到所有目的地的最新估计）打包发送给**所有**直接相邻的邻居。
	- **结果**：邻居收到后，又会进入它们自己的“第二阶段”，从而形成连锁反应。

##### 4. DV 维护的关键特性

1. 异步性 (Asynchronous)
	- 节点之间不需要“对表”。A 节点可以现在计算，B 节点可以 10 秒后收到后再计算。信息是在网络中像波浪一样传播的。
2. 分布式 (Distributed)
	- 每个节点只根据：本地已知的链路成本 $c(x,v)$，邻居传来的二向信息 $d_v(y)$
	- 进行计算。它永远不知道完整的网络长什么样（例如它不知道邻居后面还连了谁，它只相信邻居给的数字）。
3. 迭代收敛
	- 只要网络拓扑不再发生变化，这些节点就会不断地互相交换向量。每一次交换，节点都会获得更远的路径信息。
		- 第一次迭代：获得 1 跳范围内的路径。
		- 第二次迭代：获得 2 跳范围内的路径。
	- 以此类推，直到所有节点的路由表都不再变化（达到**不动点**），此时网络达到**收敛 (Convergence)** 状态。

##### 5. 路由环路与“计数到无穷”问题

DV 算法存在一个显著缺陷，即信息的传播是非对称的。

* **好消息传得快 (Good news travels fast)**：
	- 当某条链路成本降低时，这种“好消息”会迅速通过邻居间的更新在全网收敛。
* **坏消息传得慢 (Bad news travels slow)**：
	- 当链路成本大幅增加或失效时，可能会产生**路由环路 (Routing Loop)**。
	* 当路径变差或中断时，节点会倾向于寻找“替代路径”。由于它们没有全局视角，往往会误把原本就经过自己的路径当成替代路径，从而陷入互相欺骗的死循环。

**“计数到无穷 (Count-to-Infinity)”示例：**
1. 假设路径 $X \leftarrow Y \leftarrow Z$，原本 $Y$ 通过直接链路到 $X$ 的成本为 $4$，$Z$ 通过 $Y$ 到 $X$ 的成本为 $5$。
2. 若 $c(Y,X)$ 变为 $60$。$Y$ 更新时，会看到 $Z$ 曾通告过“我到 $X$ 的成本是 $5$”。
3. $Y$ 误以为可以通过 $Z$ 到达 $X$，于是计算 $d_Y(X) = c(Y,Z) + d_Z(X) = 1 + 5 = 6$。
4. 随后 $Z$ 发现 $Y$ 的成本变了，又更新自己的 $d_Z(X) = 1 + 6 = 7$。
5. 这种错误的更新会在 $Y$ 和 $Z$ 之间往复，直到成本值增加到定义的“无穷大”（如 RIP 协议中规定的 16 跳）为止。如果 $Y$ 和 $Z$ 每 30 秒交换一次数据，从 5 数到 16 需要好几分钟。在这几分钟里，去往 $X$ 的数据包会在 $Y$ 和 $Z$ 之间不停地打转（环路），直到丢包。这就是所谓的**收敛极慢**。

##### 6. 解决方案：毒性逆转 (Poisoned Reverse)

为了解决这种两个节点间的路由环路，引入了“毒性逆转”规则：

* **核心思想**：如果节点 $Z$ 经过**邻居** $Y$ 到达目的地 $X$，那么 $Z$ 向 $Y$ 通告路径信息时，会谎称其到 $X$ 的距离为**无穷大** ($d_Z(X) = \infty$)。
* **效果**：这样 $Y$ 在链路成本增加时，就不会试图通过 $Z$ 去寻找通往 $X$ 的路径，从而打破了 $Y$ 和 $Z$ 之间的循环依赖。
* **局限性**：毒性逆转只能解决涉及**两个直接相邻节点**的环路，无法完全消除涉及三个或更多节点的复杂环路。

##### 7. LS 与 DV 算法对比

| 特性 | 链路状态 (LS) | 距离向量 (DV) |
| :--- | :--- | :--- |
| **拓扑知识** | 全局 (获取全网地图) | 局部 (仅知邻居) |
| **消息传递** | 泛洪广播 (对全网发送) | 仅与邻居交换信息 |
| **收敛速度** | 快 | 慢 (且可能产生环路) |
| **鲁棒性** | 节点可能广播错误的链路成本 | 节点可能广播错误的路径成本 (错误会扩散) |


#### 4.5.3 分层路由 (Hierarchical Routing)

* **动机：** 在理想的小型实验网络中，我们可以用 *Dijkstra* 或 *Bellman-Ford* 算法算出所有路径。但在现实的互联网中，有两个无法逾越的障碍：
    1.  **规模 (Scale):** 互联网的规模巨大，单个路由器无法存储所有目的地的路由表。路由算法的计算开销也会爆炸。每当一个偏远地区的链路断开，全球所有路由器都要重新计算，这会造成网络带宽被路由更新信息占满。
    2.  **管理自治 (Administrative Autonomy):** 互联网是“网络的网络”，每个网络（公司、大学）希望有权决定自己内部使用什么协议，并且不希望外界知道自己内部详细的网络拓扑。
* **解决方案：** 将路由器组织成**自治系统 (Autonomous Systems, AS)**。


* **AS (自治系统):** 一个 AS 通常是由某个管理机构（如一个 ISP 或一个大型企业）控制的一组路由器。
	* 每个全球可达的 AS 都有一个唯一的编号（AS Number）。
	* 内部路由被隐藏在 AS 内部。外界只看到这个 AS，而看不到 AS 里面的具体路由器。
* **AS 内部路由 (Intra-AS Routing / IGP):**
    * 也称为**内部网关协议 (Interior Gateway Protocols, IGP)**。
    * 在*同一个* AS 内部运行，所有路由器运行相同的协议。管理员可以随意更换协议，不影响外界。
    * **目标：** 在 AS 内部找到最优路径。追求**性能最大化**。
    * **协议：** **RIP**, **OSPF**, IGRP (Cisco 专用)。
* **AS 间路由 (Inter-AS Routing / EGP):**
    * 也称为**外部网关协议 (Exterior Gateway Protocols, EGP)**。
    * 在*不同* AS 之间运行。
    * **目标：** 在 AS 之间找到可达的、符合*策略*的路径。
    * **协议：** **BGP**(Border Gateway Protocol)。GP 负责把分散的 AS 粘合成一个整体的互联网。
* **网关路由器 (Gateway Router):** 位于 AS 边缘，它一方面通过 IGP 知道 AS 内部的所有路径，另一方面通过 EGP 与其他 AS 的网关交流，了解如何到达全球其他地方。
* **热土豆路由 (Hot potato routing):** 当一个 AS 决定如何将数据包发往 AS **外部**时，它会将数据包转发给（AS 内部）路径成本最低的那个网关路由器，尽快将数据包“扔”出自己的网络。


---

### 4.6 互联网中的路由 (Routing in the Internet)

#### AS 内部路由协议 (IGP)

##### 4.6.1 RIP (Routing Information Protocol) 

RIP 是互联网中最古老的**内部网关协议 (IGP)** 之一。它是一种典型的基于**距离向量 (Distance Vector, DV)** 算法的路由协议，设计目标是简单、易于实现，适用于小型、自治的网络环境。

1. 核心度量标准：跳数 (Hop Count)
	- 在 RIP 中，路径的“成本”仅由**跳数 (Hops)** 决定。
		* **定义**：从源到目的地经过的路由器数量。
		* **计算**：直连网络的跳数为 0，每经过一个路由器，跳数加 1。
		* **局限性**：由于只看跳数，不考虑链路的带宽、延迟或拥塞情况。例如，一条经过 2 个路由器的 10M 链路在 RIP 看来，优于经过 3 个路由器的 1000M 链路。
2. 最大跳数与“无穷大”
	- 为了解决距离向量 *DV* 算法中“计数到无穷”问题，RIP 引入了硬性的规模限制：
	* **最大有效跳数**：15 跳。
	* **不可达标识**：16 跳被定义为**无穷大 ($\infty$)**，表示目的地不可达。
	* **设计意图**：这限制了 RIP 只能在小型局域网或企业网中使用（直径不能超过 15 个路由器）。
3. 路由通告 (Advertisements) 机制
	- RIP 路由器通过定期交换信息来同步路由表。
	* **周期性更新**：大约每 **30 秒**，路由器会向邻居发送其完整的路由表副本。
	* **通告内容**：被称为 **RIP 响应报文 (Response Message)** 或 **RIP 广告 (Advertisement)**，包含了一组 (目的地, 跳数) 的列表。
	* **传输协议**：RIP 报文封装在 **UDP** 数据报中，使用 **520** 端口。虽然它运行在应用层，但其目的是为了配置网络层的转发表。
4. 链路失效与容错
	- RIP 通过超时机制来判断邻居是否发生故障：
	* **180 秒超时**：如果一个路由器在连续 180 秒（即 6 个更新周期）内没有收到来自某个邻居的通告，则认为该邻居已失效。
	* **应对措施**（在一次播报中）：
	    1. 路由毒化：路由器会将**经过该邻居的所有路径成本**设为 16（不可达），是发现故障后的**紧急广播**。
	    2. 随后触发**毒性逆转 (Poisoned Reverse)** 机制，防止产生环路。这是一条专门针对“下一跳”邻居的规则。如果路由器 A 经过邻居 B 到达目的地 X，那么当 A 向 B 通告路由时，A 会告诉 B：“我到 X 的距离是 **16**（无穷大）”。
5. 协议的实现：routed 进程
	- RIP 通常不是直接硬编码在路由器的内核硬件中，而是作为一个软件进程运行。
	* **实现形式**：在 Unix/Linux 系统中，该进程通常被称为 **`routed` (Route Daemon)**。
	* **工作逻辑**：
	    1. `routed` 进程在应用层维护路由信息。
	    2. 它监听 UDP 520 端口的更新消息。
	    3. 根据收到的信息计算出最优路径后，通过系统调用更新操作系统内核中的 **IP 转发表 (Forwarding Table)**。
6. RIP 的优缺点总结

| 优点                        | 缺点                              |
| :------------------------ | :------------------------------ |
| **配置极其简单**：几乎不需要手动干预。     | **收敛速度慢**：遇到故障时需要“计数到 16”，反应迟钝。 |
| **资源消耗低**：对 CPU 和内存的要求很小。 | **规模受限**：无法支持超过 15 跳的大型网络。      |
| **易于理解**：基于简单的跳数逻辑。       | **路由选择不合理**：忽略了链路带宽等关键性能指标。     |

{% note default '**RIP 协议为何使用“定期更新” (Periodic Update)**' %}

虽然 DV 算法理论上提倡“有变化才更新”，但 RIP 协议作为工业实现，必须结合 **定期更新**（每 30 秒一次）和 **触发更新** (Triggered Update) 来确保系统的稳定性，其核心原因如下：

* **容错机制 (Fault Tolerance)：** >   RIP 报文封装在 **UDP** 数据报中。由于 UDP 是不可靠传输，如果仅依赖一次性的“触发更新”且该报文在网络中丢包，接收方将永远无法获知路径变化。定期更新提供了**强制同步**的“兜底”机制。

* **存活检测 (Heartbeat / 活性检测)：** >   RIP 协议没有专门的 `Hello` 报文（心跳包）。路由器通过是否能按时收到邻居的定期路由通告来判断其存活状态。若连续 **180 秒**（即 6 个周期）未收到信息，则判定邻居失效并进入容错处理。

* **防止静默状态 (Preventing Silence)：** >   在分布式系统中，定期通告能确保全网始终处于活跃的同步状态，避免因长时间无消息而无法区分“网络稳定”与“节点死机”。

**总结：** RIP 通过“触发更新”追求响应速度，通过“定期更新”解决 UDP 丢包及邻居状态监测的现实问题，二者相辅相成。

{% endnote %}
##### 4.6.2 OSPF (Open Shortest Path First) 

OSPF 是目前互联网中最广泛使用的**内部网关协议 (IGP)**。它克服了 RIP 的许多限制，适用于大型、复杂的企业级网络。

###### 1. 基本特性
* **算法类型**：基于**链路状态 (Link State, LS)** 路由算法，核心是 **Dijkstra 算法**。
* **“开放” (Open)**：表示该协议是公开发布的 IETF 标准（RFC 2328），任何厂商的路由器都可以实现并互相通信，而不像 Cisco 的 IGRP 是私有的。
* **收敛速度**：由于每个路由器都掌握全网拓扑，一旦链路状态发生变化，收敛速度远快于 RIP，且不会产生环路。

###### 2. 链路状态通告 (LSA) 与泛洪 (Flooding)
* **工作机制**：当链路状态（如开启、断开、成本变化）发生改变时，路由器会产生 **LSA (Link State Advertisement)**。
* **泛洪 (Flooding)**：LSA 会被发送给 AS 内的所有其他路由器。这意味着 AS 内的**每一个**路由器都拥有一张完全相同的、完整的全网地图（链路状态数据库）。
* **更新触发**：除了定时刷新外，一旦状态变化立即触发更新，保证了信息的一致性。

###### 3. 协议栈位置：直接承载于 IP
* **传输方式**：与 RIP 使用 UDP 不同，OSPF 报文**直接承载在 IP 数据报中**。
* **协议号**：IP 首部的协议字段值为 **89**。
* **设计意图**：不使用 TCP 或 UDP 是为了减少开销，并确保在传输层协议尚不可用或不稳定的情况下，路由信息仍能高效传递。

###### 4. 高级特性
* **安全性 (Security)**：OSPF 支持认证机制。路由器之间交换的报文可以经过 MD5 等算法加密，防止恶意攻击者伪造路由信息。
* **多倍路径允许 (ECMP)**：如果到目的地有多条成本相同的路径，OSPF 允许流量在这几条路径上进行负载均衡，而 RIP 只能选一条。
* **服务质量 (QoS)**：支持针对不同的 TOS (服务类型) 计算不同的链路成本。

###### 5. 分层 OSPF (Hierarchical OSPF)
为了在大规模自治系统 (AS) 中限制泛洪带来的开销（避免成千上万台路由器同时泛洪造成网络瘫痪），OSPF 引入了区域化管理：

* **区域 (Areas)**：将一个大的 AS 划分为多个小的逻辑块。
    * **泛洪限制**：链路状态的详细信息只在区域内部泛洪。
    * **路由汇总**：区域内部的拓扑对外部不可见，只向外通告汇总后的路径。
* **骨干区域 (Backbone Area / Area 0)**：
    * 它是分层结构的核心，所有非骨干区域必须物理上或逻辑上连接到骨干区域。
    * 作用：负责在不同非骨干区域之间中转路由信息。
* **区域边界路由器 (Area Border Routers, ABR)**：
    * 位于区域边缘的“外交官”，同时连接骨干区域和其他区域。
    * 职责：将本区域的路由信息汇总后发给骨干区域，或者将其他区域的信息带回本区域。
* **AS 边界路由器 (ASBR)**：
    * 负责连接当前的 OSPF AS 与其他的 AS（如运行 BGP 的网络）。

###### 6. OSPF 与 RIP 的对比总结

| 特性       | RIP          | OSPF         |
| :------- | :----------- | :----------- |
| **算法**   | 距离向量 (DV)    | 链路状态 (LS)    |
| **度量标准** | 跳数 (最大15)    | 成本 (通常基于带宽)  |
| **收敛速度** | 慢 (可能环路)     | 快            |
| **分层支持** | 不支持          | 支持 (Area 分层) |
| **协议承载** | UDP (端口 520) | IP (协议号 89)  |

#### AS 间路由协议 (EGP)

##### 4.6.3 BGP (边界网关协议) 

BGP 是互联网中唯一的 **AS 间 (Inter-AS)** 路由协议，负责将全球数万个自治系统“粘合”在一起。

###### 1. 核心定位
* **目标**：不仅寻找路径，更重要的是根据**策略 (Policy)** 实现子网的**可达性 (Reachability)**。
* **连接方式**：基于 **TCP** (端口 179) 的半永久连接，称为 **BGP 会话**。
###### 2. 两种会话类型
* **eBGP (External BGP)**：用于**不同 AS 之间**，从邻居 AS 获取路由信息。
* **iBGP (Internal BGP)**：用于**同一 AS 内部**，将从外部学到的路由信息分发给 AS 内的所有路由器。
###### 3. 关键路径属性 (Attributes)
* **AS-PATH**：记录路由经过的所有 AS 编号。
    * 作用：**检测环路**（若看到自己 AS 编号则拒绝）；选择较短路径。
* **NEXT-HOP**：指向通往目的地的下一个具体 IP 地址（通常是相邻 AS 的网关接口）。
###### 4. 路由选择标准 (优先级排序)
BGP 并不简单看跳数或带宽，而是按以下顺序选择：
1. **本地偏好 (Local Preference)**：由管理员设置，基于政策或经济协议（最高优先级）。
2. **最短 AS-PATH**：经过的自治系统数量最少。
3. **热土豆路由 (Hot Potato Routing)**：选择距离本 AS 内部出口最近（IGP 成本最低）的网关。
4. **其他准则**（如 BGP 标识符 ID 等）。
###### 5. 总结：IGP vs BGP
* **IGP (OSPF/RIP)**：在 AS 内部运行，关注**性能（快）**。
* **BGP**：在 AS 之间运行，关注**策略（商业/安全/可达性）**。

---

### 软件定义网络 (Software Defined Networking, SDN)

#### 1. 传统路由 vs. SDN
* **传统路由 (Per-router control plane):**
    * **控制平面 (Control Plane)**（运行路由算法如 OSPF, BGP）和**数据平面 (Data Plane)**（根据转发表转发数据包）被**紧密耦合**在同一台路由器中。
    * 路由器是“整体式”的、封闭的、专有的（如 Cisco IOS）。
* **SDN (Logically centralized control plane):**
    * **控制平面与数据平面分离 (Separation)**。
    * **数据平面：** 由简单的、“哑”的交换机硬件组成。
    * **控制平面：** 是一个**逻辑上集中 (logically centralized)** 的**远程控制器 (Remote Controller)**，它是一个软件程序。
    * 控制器负责计算转发表，然后将转发表分发到数据平面的交换机上。

#### 2. 为什么需要 SDN？
1.  **易于网络管理：** 集中式编程比在每台路由器上配置分布式算法更容易，可以避免配置错误。
2.  **开放性 (Open)：** 打破了传统路由器厂商的“垂直集成”和“封闭”系统（类比大型机 vs. PC）。
3.  **灵活的流量工程 (Traffic Engineering):**
    * 传统路由（LS, DV）很难实现精细的流量控制（例如，将 u-z 的流量一半走 uvwz，一半走 uxyz）。
    * 使用 SDN，控制器可以*显式*地编程任何它想要的路径。

#### 3. SDN 架构
1.  **网络控制应用 (Control Applications):**
    * SDN 的“大脑”，实现路由、负载均衡、防火墙等逻辑。
2.  **SDN 控制器 (SDN Controller / Network OS):**
    * 维护网络状态（拓扑、交换机信息、流表）。
    * 为上层应用提供 **北向接口 (Northbound API)**。
    * 通过 **南向接口 (Southbound API)** 与交换机通信。
3.  **数据平面交换机 (Data-plane Switches):**
    * 根据控制器下发的**流表 (Flow tables)** 进行转发。

#### 4. OpenFlow (南向接口)
* OpenFlow 是 SDN 中事实上的标准南向接口协议。
* **核心思想：** **基于流 (flow-based)** 的**广义转发 (generalized forwarding)**。
* **流表 (Flow Table):**
    * **匹配 (Pattern):** 匹配数据包头部的多个字段（L2 MAC, L3 IP, L4 Port 等）。
    * **动作 (Actions):** 转发 (forward)、丢弃 (drop)、修改 (modify) 或发送到控制器 (send to controller)。
* **OpenFlow 统一了多种设备：**
    * **路由器：** 匹配目的 IP -> 动作：转发。
    * **交换机：** 匹配目的 MAC -> 动作：转发/泛洪。
    * **防火墙：** 匹配 IP/Port -> 动作：允许/拒绝。
    * **NAT：** 匹配 IP/Port -> 动作：重写地址/端口。
* **OpenFlow 协议消息：**
    * **控制器 -> 交换机：** `Modify-state` (添加/删除流表项), `Packet-out` (将一个特定数据包从指定端口发出)。
    * **交换机 -> 控制器：** `Packet-in` (收到一个无法匹配流表的包，请求控制器指示), `Port-status` (报告端口/链路故障)。

#### 5. “软件定义” (Software Defined) 的本质
* **定义：** 用软件去定义系统的功能，用软件给硬件赋能。
* **本质：** “深度”可编程。将原来硬件中“写死”的功能，以软件可编程的方式来实现。
* **API：** 解除了软硬件之间的耦合关系。
* *类比：* 操作系统、虚拟机 (VM)、容器 (Containers)、智能手机（相对于功能机）都是“软件定义”思想的体现。