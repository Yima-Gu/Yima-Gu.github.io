---
title: 从 Obsidian 到 Hexo：打造完美的数学公式与图片发布流
date: 2025-06-24
tags:
  - "Hexo"
  - "Obsidian"
  - "MathJax"
escaped: true
images_converted: true
syntax_converted: true

---
对于许多技术爱好者和研究者来说，Obsidian 是无与伦比的个人知识管理（PKM）神器，而 Hexo 则是搭建静态博客的绝佳选择。然而，当我们试图将两者结合，打造一个从“笔记”到“发布”的流畅工作流时，常常会遇到一个巨大的障碍：Obsidian 中便捷的语法（尤其是数学公式和图片链接）与 Hexo 的标准渲染流### 结语

通过结合 Hexo 的 Fluid 主题配置、Pandoc 渲染器、一个智能的 Python 图片转换脚本和一个自动化的发布脚本，我们最终打通了 Obsidian 和 Hexo 之间的"任督二脉"。这套工作流将所有复杂性都封装在了工具背后，让我们可以重新专注于最重要的事——思考与创作。

主要技术栈：
- **主题**：Fluid 主题，内置 MathJax 支持
- **渲染器**：hexo-renderer-pandoc，对数学公式友好
- **转换脚本**：convert_obsidian_to_hexo.py，专门处理图片链接转换
- **发布脚本**：publish.sh，一键完成转换、清理、生成、部署

[^1]: <https://zhuanlan.zhihu.com/p/392994381>冲突。

本文将记录一次完整的“踩坑”与“填坑”过程，最终形成一套强大、可靠的自动化解决方案，让你只需一条命令，即可将 Obsidian 笔记完美发布到 Hexo 博客。

对于网站的搭建可以参考[^1]

### 问题所在：便利性与标准化的冲突

我们的核心痛点在于，Obsidian 为了用户体验，使用了许多非标准的 Markdown 语法，而 Hexo 依赖于标准的渲染器。

| 功能 | 你在 Obsidian 中的写法 | 标准 Markdown / HTML | 冲突点 |
| :--- | :--- | :--- | :--- |
| **下标** | `$x\_i$` | `<em>` 标签 | `_` 被 Markdown 错误地解析为斜体。 |
| **图片嵌入** | `![my_image.png](my_image.png)` | `![alt](image.png)` | Hexo 完全不认识 `![...](...)` 这种 Wikilink 语法。 |
| **图片粘贴** | `![](image.png)` | `![](image.png)` | Obsidian 可能会生成指向你本地硬盘的绝对路径，这在网站上无效。 |
| **LaTeX 命令** | `\frac`, `\begin{aligned}` | `\` | `\` 是特殊转义符，在处理中可能被“吃掉”。 |
| **公式换行** | `\\` | `\` | 两个 `\` 可能在处理后只剩一个，导致换行失败。 |

手动去修改每一篇文章中的这些问题，无疑是一场灾难。我们的目标是：**在 Obsidian 中自由写作，用一个自动化工具处理所有兼容性问题。**

### 第一步：配置 Hexo，为数学公式提供最佳渲染环境

在解决兼容性问题之前，我们首先要确保 Hexo 本身具备渲染高质量数学公式的能力。我们采用现代化的 Fluid 主题，它内置了对数学公式的完美支持。

1. **安装 Fluid 主题**
   Fluid 是一个现代化的 Hexo 主题，内置了对数学公式的完美支持：
   ```bash
   npm install hexo-theme-fluid
   ```

2. **更换 Markdown 渲染器**
   由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，我们需要更换为 Pandoc 渲染器：
   ```bash
   npm uninstall hexo-renderer-marked --save
   npm install hexo-renderer-pandoc --save
   ```
   
   **重要**：还需要[安装 Pandoc](https://github.com/jgm/pandoc/blob/master/INSTALL.md) 到你的系统中。

3. **配置 `_config.yml`**
   在你的博客根目录下的 `_config.yml` 文件中，设置主题为 fluid：
   ```yaml
   theme: fluid
   ```

4. **配置 `_config.fluid.yml`**
   在你的博客根目录下创建 `_config.fluid.yml` 文件，配置数学公式支持：
   ```yaml
   post:
     math:
       enable: true
       specific: true # 强烈建议设为 true，只在有数学公式的页面加载
       engine: 'mathjax' # 使用 MathJax 引擎
   ```

5. **在文章中启用数学公式**
   对于需要使用数学公式的文章，在 front-matter 中添加 `math: true`：
   ```yaml
   ---
   title: 文章标题
   date: 2025-01-01
   math: true
   ---
   ```

6. **清除缓存**
   安装完成后执行：
   ```bash
   hexo clean
   ```

完成这一步，你的 Hexo 博客就已经拥有了渲染任何标准 LaTeX 公式的能力。

**数学公式书写格式：**

行内公式：`$E=mc^2$` 

块级公式：
```latex
$$
\frac{\partial f}{\partial x} = 2\rho \frac{\partial f}{\partial \rho}
$$
```

现在，我们来解决如何将 Obsidian 的"方言"转换成"标准普通话"。

### 第二步：打造你的专属"智能翻译官"—— Python 自动化脚本

我们将编写一个 Python 脚本，它将作为我们工作流的核心。它的任务是读取我们从 Obsidian 写好的 Markdown 文件，并自动完成所有必需的修复和转义。

在你的博客根目录下，创建一个名为 `convert_obsidian_to_hexo.py` 的文件，并将以下代码粘贴进去。

```python
# convert_obsidian_to_hexo.py
import re
import sys
import os
import shutil
import argparse
import urllib.parse

def convert_image_links(content, image_prefix):
    """
    将本地图片路径和 wikilinks 转换为新的 URL 前缀。
    """
    # --- 用于修复绝对本地路径 (例如 file:///C:/...) 的函数 ---
    def fix_local_path(match):
        alt_text = match.group(1)
        local_path_raw = match.group(2)
        # 解码 URL 编码的字符，例如 %20 (空格)
        local_path = urllib.parse.unquote(local_path_raw)
        # 从路径中仅获取文件名
        filename = os.path.basename(local_path)
        # 重新编码文件名以使其对 URL 安全
        encoded_filename = urllib.parse.quote(filename)
        return f"![{alt_text}]({image_prefix}{encoded_filename})"

    # 用于查找带有绝对本地路径的图片链接的正则表达式
    local_path_regex = re.compile(r'!\[(.*?)\]\(((?:[a-zA-Z]:|file:)[\\/].*?)\)')
    content = local_path_regex.sub(fix_local_path, content)

    # --- 用于替换 wikilinks (例如 ![image.png](image.png)) 的函数 ---
    def replace_wikilink(match):
        filename = match.group(1).strip()
        encoded_filename = urllib.parse.quote(filename)
        return f"![{filename}]({image_prefix}{encoded_filename})"

    # 用于查找 wikilink 样式的图片嵌入的正则表达式
    wikilink_regex = re.compile(r'!\[\[(.*?)\]\]')
    content = wikilink_regex.sub(replace_wikilink, content)

    return content

def process_single_file(filepath, create_backup, image_prefix):
    """
    处理单个 markdown 文件以进行图片链接转换。
    """
    print(f"正在检查: {filepath}")
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            original_content = f.read()

        # 检查文件是否已被转换
        fm_match = re.match(r'---\s*?\n(.*?)\n---\s*?\n', original_content, re.DOTALL)
        if fm_match and 'images_converted: true' in fm_match.group(1):
            print("  -> 跳过: 文件已被标记为已转换。")
            return

        # 如果启用，则创建备份
        if create_backup:
            backup_path = filepath + ".bak"
            shutil.copy2(filepath, backup_path)

        # 转换图片链接
        converted_content = convert_image_links(original_content, image_prefix)

        # 如果内容已更改，则将其写回文件
        if original_content != converted_content:
            # 更新或添加 front matter 以标记为已转换
            if fm_match:
                front_matter_content = fm_match.group(1)
                new_front_matter = front_matter_content.strip() + "\nimages_converted: true\n"
                main_content_start_index = fm_match.end()
                final_content = original_content[:main_content_start_index].replace(front_matter_content, new_front_matter) + converted_content[main_content_start_index:]
            else:
                new_front_matter = "images_converted: true\n"
                final_content = f"---\n{new_front_matter}---\n\n{converted_content}"
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(final_content)
            print("  -> 图片链接已转换并已标记文件。")
        else:
            print("  -> 无需转换任何图片链接。")

    except Exception as e:
        print(f"  -> 处理文件 {filepath} 时出错: {e}", file=sys.stderr)

def process_path(path, create_backup, image_prefix):
    """
    递归处理给定路径（文件或目录）中的文件。
    """
    if os.path.isfile(path):
        if path.endswith(".md"):
            process_single_file(path, create_backup, image_prefix)
        else:
            print(f"跳过非 markdown 文件: {path}")
    elif os.path.isdir(path):
        print(f"正在处理目录: {path}")
        for root, _, files in os.walk(path):
            for file in files:
                if file.endswith(".md"):
                    file_path = os.path.join(root, file)
                    process_single_file(file_path, create_backup, image_prefix)
    else:
        print(f"错误: 路径不存在: {path}", file=sys.stderr)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="转换 Markdown 文件中的图片链接。")
    parser.add_argument("paths", metavar="PATH", type=str, nargs='+', help="一个或多个要处理的 markdown 文件或目录的路径。")
    parser.add_argument("--image-prefix", type=str, default="|images|", help="图片链接的伪装绝对路径前缀 (例如, '|images|' 会变成 '/images/')。")
    parser.add_argument("--no-backup", action="store_false", dest="create_backup", help="禁用创建 .bak 备份文件。")
    
    args = parser.parse_args()
    
    # 从其伪装形式恢复前缀
    disguised_prefix = args.image_prefix
    image_prefix = disguised_prefix.replace('|', '/')
    print(f"--- 接收到伪装前缀: '{disguised_prefix}', 已恢复为: '{image_prefix}' ---")

    for path in args.paths:
        process_path(path, args.create_backup, image_prefix)
        
    print("\n转换过程完成。")
```

### 第三步：封装一切的“总指挥”—— Shell 脚本

为了实现“一键发布”，我们编写一个 shell 脚本来调用 Python 脚本，并执行所有 Hexo 命令。

在你的博客根目录下，创建一个名为 `publish.sh` 的文件，并粘贴以下代码：

```bash
#!/bin/bash

# publish.sh - Final workaround version using parameter disguise.

set -e

# --- Default Configuration ---
PYTHON_SCRIPT="convert_obsidian_to_hexo.py" # 确保这个文件名和你的Python脚本文件名一致
SOURCE_DIR="source/_posts/"
# This is the REAL prefix we want.
IMAGE_PREFIX="/images/" 

# --- ANSI Color Codes ---
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# --- Argument Parsing ---
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -s|--source) SOURCE_DIR="$2"; shift; shift ;;
        -i|--image-prefix) IMAGE_PREFIX="$2"; shift; shift ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
done

# --- Main Script Logic ---

# Step 1: Disguise the parameter and convert Markdown files
echo -e "${YELLOW}>>> Step 1: Converting Markdown files...${NC}"
echo -e "${CYAN}Source:           ${SOURCE_DIR}${NC}"
echo -e "${CYAN}Original Prefix:  ${IMAGE_PREFIX}${NC}"

# 将斜杠替换为不会触发路径扩展的字符，比如管道符 |
# 例如："/images/" 变成 "|images|"
DISGUISED_PREFIX=$(echo "$IMAGE_PREFIX" | sed 's#/#|#g')
echo -e "${CYAN}Disguised Prefix: ${DISGUISED_PREFIX}${NC}"

if [ ! -f "$PYTHON_SCRIPT" ]; then
    echo -e "Error: Python script '$PYTHON_SCRIPT' not found."
    exit 1
fi

# 将伪装的前缀传递给 Python 脚本
python "$PYTHON_SCRIPT" "$SOURCE_DIR" --image-prefix "$DISGUISED_PREFIX"
echo -e "${GREEN}--- Markdown conversion complete.${NC}"

# Step 2: Clean old files
echo -e "\n${YELLOW}>>> Step 2: Cleaning old Hexo files...${NC}"
hexo clean
echo -e "${GREEN}--- Clean complete.${NC}"

# Step 3: Generate new site
echo -e "\n${YELLOW}>>> Step 3: Generating new site files...${NC}"
hexo g
echo -e "${GREEN}--- Generation complete.${NC}"

# Step 4: Deploy to GitHub
echo -e "\n${YELLOW}>>> Step 4: Deploying to GitHub Pages...${NC}"
hexo d
echo -e "${GREEN}--- Deployment complete.${NC}"

echo -e "\n${GREEN}✅ All steps completed successfully! Your blog has been published.${NC}"
```
**在 Windows 上使用 PowerShell**：
```powershell
# 在 PowerShell 中运行
.\publish.sh
```

**或者直接在 PowerShell 中运行**：
```powershell
# 直接在 PowerShell 中运行完整的发布流程
python convert_obsidian_to_hexo.py source/_posts/ --image-prefix "|images|"
hexo clean
hexo g
hexo d
```

### 你的终极工作流

现在，从写作到发布的完整流程被简化为了三个简单步骤：

1. **写作**：在 Obsidian 中自由地写作，使用你最喜欢的 `![image.png](image.png)` 语法插入图片，用标准 LaTeX 书写公式。
2. **同步**：将写好的 `.md` 文件和相关图片分别放入你 Hexo 项目的 `source/_posts/` 和 `source/images/` 目录。
3. **发布**：在你的博客根目录下，打开 PowerShell 终端，运行：
    ```powershell
    .\publish.sh
    ```

一切都将自动完成。如果你有特殊需求，比如处理草稿箱或使用不同的图片目录，还可以使用参数：
```powershell
.\publish.sh -s source/_drafts/ -i /assets/
```

### 结语

通过结合 Hexo 的正确配置、一个智能的 Python 转换脚本和一个自动化的 Shell 发布脚本，我们最终打通了 Obsidian 和 Hexo 之间的“任督二脉”。这套工作流将所有复杂性都封装在了工具背后，让我们可以重新专注于最重要的事——思考与创作。

[^1]: https://zhuanlan.zhihu.com/p/392994381
