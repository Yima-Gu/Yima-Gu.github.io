---
title: DL Note-1 Intro
date: 2025-09-21 12:30
tags:
  - DeepLearning
math: true
comments: true
---

**人工智能 (*Artificial Intelligence*)**：宏观的目标，即创造出能够模拟、延伸和扩展人类智能的机器。

**机器学习 (*Machine Learning*)**：实现人工智能的一种核心方法。它的特点是**不通过显式编程来解决问题，而是让算法从数据中自动学习规律**。

**深度学习(*Deep Learning*)**：它主要**使用一种叫做“神经网络”的复杂结构**，从海量数据中**获取高度抽象的特征**。


深度学习的魅力在于，它能从海量数据中**自动提取高度抽象的特征**，这主要通过深度神经网络来实现。我们可以将这个过程类比为**对数据进行坐标系变换**，通过不同的变换方式，我们能用新的视角来处理同一个问题。尽管深度学习取得了巨大成功，但传统的规则系统在许多机器学习任务中依然扮演着不可或缺的角色。

{% note default '坐标系变换' %}

1. **想象一个问题**：假设你有一张纸，上面混杂地撒着红色和蓝色的豆子，它们混在一起，你无法用一把直尺就将它们完美分开。
2. **一次“变换”**：现在，你抓住这张纸（坐标系），将它进行拉伸、弯曲、折叠。经过这次操作，神奇的事情发生了：所有的红豆子都跑到了纸的左边，蓝豆子都跑到了右边。现在，你只需要用一把直尺就能轻松地将它们分开了。
3. **深度学习在做什么**：深度学习中的每一个“层”（layer）都在做一次类似上面那样的“坐标系变换”。它将原始的、线性不可分的数据，通过一系列复杂的空间变换，转换到一个新的、高维的空间中，在这个新空间里，数据变得更容易被分类。

所以，深度学习的“深度”就体现在它执行了一连串（成百上千次）这样的变换，从而能够解开那些缠绕得极其复杂的数据模式。

{% endnote %}

{% note default '规则系统 (*Rule-based System*)' %}
在机器学习出现之前，我们实现AI的方式主要是“规则系统”。想象一下编写一个识别猫的程序，你可能需要写下成千上万条规则：

- `如果` 有毛茸茸的耳朵 `并且` 有胡须 `并且` 会“喵”叫，`那么` 它可能是一只猫。

这种方式非常脆弱且复杂。而机器学习则完全不同，你不需要告诉计算机“猫有什么特征”，你只需要给它看成千上万张猫的图片，它会**自己总结**出什么是猫。这就是“不显式编程”的含义。

{% endnote %}
### Framework

在学习算法中，我们首先要指定一个**函数族 (family of functions)**，然后用数据来从这个族中找到最匹配的那个函数。这个过程的目标就是找出**最优的函数**。

{% note default '“假设空间”和“最优函数族”' %}

- **假设空间 (Hypothesis Space)**：也叫“函数族”，你可以把它想象成一个“工具箱”。
- 一个只包含直尺的工具箱，它能画出所有的直线。这就是“线性模型”的假设空间。
- 一个包含各种曲线尺的工具箱，它能画出各种平滑的曲线。这就是“多项式模型”的假设空间。
- 一个拥有橡皮泥的工具箱，理论上可以捏出任何形状。这就是“神经网络”的假设空间，它非常强大。
- **最优函数族**：指为你的特定问题**选择最合适的那个“工具箱”**。如果你的数据点本身就大致在一条直线上，那么“直尺工具箱”（线性模型）就是最优的，用“橡皮泥”反而可能因为过于灵活而把问题搞砸（这叫**过拟合**）。

{% endnote %}
过拟合在你选择函数族（工具箱）的时候，其风险就已经被决定了。

<mark>泛化误差公式(*Generalization Error*)</mark>：

$$
\varepsilon_{test} \leq \hat{\varepsilon}_{train} + \sqrt{\frac{\text{complexity}}{n}}
$$

这个公式是机器学习的基石，它告诉我们如何让模型在“真实世界”中表现良好。

- $\varepsilon_{test}$ (**泛化误差**)：模型的“期末考试”成绩。它衡量模型在从未见过的新数据上的表现，这是我们最关心的指标。
- $\varepsilon_{train}$​ (**训练误差**)：模型的“平时作业”成绩。它衡量模型在训练数据上的表现。
- $\sqrt{\frac{\text{complexity}}{n}}$(**过拟合惩罚项**)：可以理解为“作业”和“考试”成绩之间的差距。
	- $complexity$ (**模型复杂度**)：模型的“难度系数”。复杂度越高，模型越容易过拟合训练数据，但在新数据上表现可能会很差。
	- $n$(数据量)：你做的“练习题”数量。练习题越多，你越能总结出通用规律，而不是记住个别题的答案。

**核心思想**：要想在期末考试中取得好成绩，你需要：

1. **平时作业分高** (训练误差小)
2. **不依赖死记硬背** (模型复杂度不能太高，或者数据量`n`要足够大来约束它)

这也引出了一个重要原则：**当且仅当需要的时候，才增加模型的复杂度。**

### Model
 
$$
\arg \min O(D;\theta) = \sum_{i=1}^{N} L(y_i, f(x_i);\theta) + \Omega(\theta)
$$

 这是机器学习的“指导思想”，它告诉模型如何学习。

 - $\arg \min_\theta$：意思是“找到一组参数 ，使得后面的表达式结果最小”。
	 - 参数  就是模型需要学习的东西（比如一条直线的斜率和截距）。
	 - $O(D;\theta)$：总目标，我们希望它越小越好。 
- $\sum L(y_i, f(x_i);\theta)$：**损失项 (Loss Term)**。 
	- 这部分计算的是模型预测值 $f(x_i)$ 与真实值 $y_i$ 之间的“差距”或“错误”。它的目标是：**让模型在训练数据上尽可能地预测准确**。对于分类问题而言，经常使用的是交叉熵损失函数（logistic）和hinge损失函数。
* **正则化项 (Regularization Term)**，也叫**惩罚项 (Penalty Term)**。 
	* 这部分是用来限制模型复杂度的。它会惩罚那些过于复杂的模型（即参数 $\theta$ 的值过大）。 
	* 它的目标是：**在拟合数据的同时，让模型本身尽可能地简单**。 
- **总结**：整个公式描述了一个**权衡 (Trade-off)**。机器学习的目标是找到一组完美的参数 $\theta$，这组参数既能让模型很好地拟合训练数据（损失项小），又能保证模型自身不至于过分复杂（惩罚项小），从而在未来的新数据上也能表现良好。


**Linear Regression**

$$
O(D;\theta) = \sum_{i=1}^{N} (y_i - \theta^T x_i)^2 + \lambda \theta^T \theta = (Y - X\theta)^T (Y - X\theta) + \lambda \theta^T \theta
$$

上述公式是关于$\theta$的二次函数，可以通过求导得到最优解。

$$
\frac{\partial O(D;\theta)}{\partial \theta} = -2 X^T (Y - X\theta) + 2 \lambda \theta = 0
$$

$$
\hat{\theta} = (X^T X + \lambda I)^{-1} X^T Y
$$

但是上述算法的复杂性为$O(n^3)$，不适用于大数据集。在软件工程中，通常使用梯度下降法。

**Logistic Regression**

$$
O(D;\theta) = \sum_{i=1}^{n} \log(1 + \exp(-y_i \theta^T x_i)) + \lambda ||\theta||_{1} = F(D;\theta) + \lambda ||\theta||_{1}
$$

这里使用的是近端梯度下降法 *proximal gradient descent*。其中的1-范数是各个分量的绝对值之和。[机器学习 | 近端梯度下降法 (proximal gradient descent)](https://www.zhihu.com/tardis/zm/art/82622940?source_id=1005)
在一些不可导的情况下如hinge损失函数，可以使用次梯度。

**Softmax Regression**

实现多分类问题，计算每个类别的概率即可，对于某个样本进行多次打分，取最高分对应的类别。

Softmax Function:

$$
P(y|x,\theta) = \frac{\exp(\theta_y^T x)}{\sum_{r=1}^{C} \exp(\theta_{r}^T x)}
$$

线性模型，用超平面对样本进行打分，然后使用softmax函数进行归一化。

$$
O(D;\theta) = -\sum_{i=1}^{n} \log P(y_i|x_i;\theta) + \lambda ||\theta||_{1}
$$

上述式子其实是对数似然函数，最大化对数似然函数等价于最小化交叉熵损失函数。


#### Aproximation and Estimation

假设空间只能表现一个有限的函数集合，有时候真值函数不一定在假设空间中。这时候假设空间中最好的函数与真值函数之间的差距称为**近似误差***Approximation Error*。学习得到的函数与空间中最好的函数的误差为**估计误差** *Estimation Error*。

{% note warning '' %}
让我们继续用“雕刻”来打比方。你的目标是完美复刻一座罗丹的《思想者》雕像，这就是“真理”（真值函数）。

1. **你的工具箱 = 假设空间 (Hypothesis Space)**。
2. **工具不行，神仙难救 = 近似误差 (Approximation Error)**
- 这个误差衡量的是你**“工具箱”本身的局限性**。假设你选择的工具箱里只有一把直尺和几块乐高积木。无论你多么努力，用这些工具也永远无法完美复刻出《思想者》流畅的人体曲线。
- 你用乐高能拼出的、最接近《思想者》的那个方块人，和真正的《思想者》雕像之间的巨大差距，就是**近似误差**。这个错误在你选择工具箱的那一刻就注定了，是**设计上**的误差。
3. **工具有了，手艺差点 = 估计误差 (Estimation Error)**
- 现在，假设你得到了一个顶级的雕刻工具箱，里面有凿子、刻刀，还有一大块完美的“橡皮泥”（神经网络）。这个工具箱足够强大，理论上完全可以复刻出《思想者》。
- 但因为你是初学者，你的**雕刻技术（训练过程）还不够娴熟**，或者你只有很少的时间（数据量不足）去雕刻。最终，你做出的雕像虽然有了人形，但细节粗糙，比例也有些失调。
- 你最终做出的这个“走样”的雕像，和一位大师用同样的工具能做出的完美雕像之间的差距，就是**估计误差**。这不是工具的错，而是你**使用过程中**的误差。 
{% endnote %}
### Model Selection

{% note default '' %}
*All models are wrong but some are useful.*


{% endnote %}
CASH (Combined Algorithm Selection and Hyperparameter optimization) 所解决的是应用机器学习中的一个核心且复杂的挑战：**如何在一个包含多种算法及其各自超参数配置的巨大搜索空间中，自动地、系统性地找到最优的模型配置。**

$$
A^*_{\lambda^*} = \arg \min_{A \in \mathcal{A}} \min_{\lambda \in \Lambda^{(i)}} \mathcal{L}(A_{\lambda}^{(i)},D_{train},D_{valid})
$$

下面，我们对该公式的各个组成部分进行严谨的拆解：

1.  **目标 ($A^*_{\lambda^*}$)**
    * 这代表了我们寻求的最优解。它不是一个单一的模型，而是一个**配置（Configuration）**，由两部分组成：
        * $A^*$：从候选算法集合中选出的**最优算法**。
        * $\lambda^*$：与最优算法 $A^*$ 相对应的**最优超参数组合**。
2.  **搜索空间 (Search Space)**
    * 这是一个分层的、结构化的空间，由两部分构成：
        * **算法空间 ($\mathcal{A}$)**：一个离散的、预定义的机器学习算法集合。例如：$\mathcal{A} = \{\text{支持向量机}, \text{随机森林}, \text{多层感知机}\}$。
        * **超参数空间 ($\Lambda_A$)**：对于算法空间 $\mathcal{A}$ 中的每一个算法 $A$，都存在一个与之关联的超参数空间 $\Lambda_A$。这个空间定义了该算法所有可调超参数的类型和取值范围。例如，对于支持向量机，$\Lambda_{SVM}$ 可能包含核函数类型 (`kernel`)、惩罚系数 `C` 的范围 `[0.1, 100]` 等。这个空间可以是多维的，并且包含连续、离散和条件参数，结构非常复杂。
3.  **优化过程 ($\arg \min_{A \in \mathcal{A}} \min_{\lambda \in \Lambda_A}$)**
    * 这描述了一个嵌套的最小化过程。外层循环遍历算法空间 $\mathcal{A}$ 中的每一个算法，内层循环则在该算法的超参数空间 $\Lambda_A$ 中进行搜索。其目标是找到能使目标函数 $\mathcal{L}$ 最小化的那一对 $(A, \lambda)$ 组合。
4.  **评估协议 ($\mathcal{L}(A_{\lambda}, D_{\text{train}}, D_{\text{valid}})$)**
    * 这是整个优化过程的核心，定义了如何评估任意一个给定配置的好坏。它包含以下标准流程：
        * **实例化 (Instantiation)**：从算法库中选择一个算法 $A$，并使用一组具体的超参数 $\lambda$ 来实例化一个待训练的模型 $A_{\lambda}$。
        * **训练 (Training)**：使用训练数据集 $D_{\text{train}}$ 对实例化的模型 $A_{\lambda}$ 进行训练。在这个过程中，模型学习其内部参数（例如，神经网络的权重）。
        * **验证 (Validation)**：训练完成后，在独立的验证数据集 $D_{\text{valid}}$ 上评估模型的性能。$D_{\text{valid}}$ 中的数据是模型在训练过程中从未见过的，因此可以提供对模型**泛化能力 (Generalization Performance)** 的无偏估计。
        * **损失函数 ($\mathcal{L}$)**：这是一个量化指标，用于计算模型在验证集上的性能。例如，对于分类问题，它可以是交叉熵损失或错误率；对于回归问题，可以是均方误差（MSE）。